<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV M3U Manager</title>
    <link rel="stylesheet" href="/static/index.css">
    <style>
        /* å¼¹çª—é€šçŸ¥æ ·å¼ */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(30, 30, 45, 0.95);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideUp 0.3s ease-out;
            min-width: 200px;
            justify-content: center;
        }

        .toast.success {
            border-left: 3px solid #10b981;
        }

        .toast.error {
            border-left: 3px solid #ef4444;
        }

        .toast.info {
            border-left: 3px solid #3b82f6;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>ğŸ“º IPTV M3U Manager</h1>
            <p>ç®¡ç†æ‚¨çš„ç›´æ’­è®¢é˜…ã€ç­›é€‰ã€ç”Ÿæˆä¸“å±åˆ—è¡¨</p>
        </header>

        <section id="created_outputs_section">
            <div class="glass-card">
                <h2>ğŸ”— å·²åˆ›å»ºèšåˆ</h2>
                <div id="output_list">æš‚æ— æ•°æ®</div>
            </div>
        </section>

        <section id="subscriptions">
            <div id="sub_form_container" class="glass-card">
                <h2 id="sub_form_title">â• æ·»åŠ è®¢é˜…æº</h2>

                <div class="tab-container">
                    <button id="tab_normal" class="tab-btn active" onclick="switchSubTab('normal')">
                        ğŸ”— æ™®é€šè®¢é˜…
                    </button>
                    <button id="tab_git" class="tab-btn" onclick="switchSubTab('git')">
                        ğŸ“¦ Git ä»“åº“
                    </button>
                </div>

                <input type="hidden" id="edit_sub_id">
                <input type="hidden" id="sub_is_enabled" value="true">
                <div class="form-group">
                    <input type="text" id="sub_name" placeholder="åç§° (ä¾‹å¦‚: å«è§†ç²¾å“)">
                </div>
                <div class="form-group">
                    <input type="text" id="sub_url" placeholder="M3U URL (å¤šä¸ªåœ°å€è¯·ç”¨è‹±æ–‡é€—å·éš”å¼€)">
                </div>
                <div class="form-group" id="ua_form_group">
                    <input type="text" id="sub_ua" list="ua_options" placeholder="User-Agent (å¯é€‰ï¼Œæ¨èé€‰æ‹©ä¸‹æ–¹å¸¸ç”¨ UA)" value="">
                    <datalist id="ua_options">
                        <option value="AptvPlayer/1.4.1">APTV (iOS/Apple TV) - æ¨è</option>
                        <option value="TiviMate/5.2.0 (Android 15)">TiviMate (Android TV) - æ¨è</option>
                        <option value="Mozilla/5.0">é»˜è®¤ (Browser)</option>
                        <option value="VLC/3.0.18">VLC Media Player</option>
                        <option value="PotPlayer/1.7">PotPlayer (Windows)</option>
                    </datalist>
                </div>
                <div class="form-group">
                    <select id="sub_auto_update"
                        style="width: 100%; padding: 12px; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); color: #fff; border-radius: 8px; outline: none;">
                        <option value="0">è‡ªåŠ¨æ›´æ–°: å…³é—­ (æ‰‹åŠ¨åˆ·æ–°)</option>
                        <option value="60">è‡ªåŠ¨æ›´æ–°: æ¯ 1 å°æ—¶</option>
                        <option value="720">è‡ªåŠ¨æ›´æ–°: æ¯ 12 å°æ—¶</option>
                        <option value="1440">è‡ªåŠ¨æ›´æ–°: æ¯ 24 å°æ—¶</option>
                        <option value="10080">è‡ªåŠ¨æ›´æ–°: æ¯ 7 å¤©</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="sub_btn" class="btn" onclick="addSubscription()">æ·»åŠ è®¢é˜…</button>
                    <button id="sub_cancel_btn" class="btn" style="display: none; background: rgba(255,255,255,0.1);"
                        onclick="cancelEditSub()">å–æ¶ˆä¿®æ”¹</button>
                </div>
            </div>

            <div class="glass-card">
                <h2>ğŸ“‹ å½“å‰è®¢é˜…</h2>
                <div id="sub_list">åŠ è½½ä¸­...</div>
            </div>
        </section>

        <section id="outputs">
            <div class="glass-card">
                <h2>ğŸ› ï¸ åˆ›å»ºèšåˆåˆ—è¡¨</h2>
                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">åç§°ä¸åç¼€</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="out_name" placeholder="èšåˆåç§° (ä¾‹å¦‚: å®¶åº­ç²¾é€‰)">
                        <input type="text" id="out_slug" placeholder="URL åç¼€ (ä¾‹å¦‚: family)">
                    </div>
                </div>

                <div class="form-group">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label
                            style="display: block; opacity: 0.9; margin: 0; font-size: 0.95em; font-weight: 500;">é€‰æ‹©è®¢é˜…æº
                            (å¤šé€‰)</label>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-sm" style="font-size: 0.8em; padding: 2px 8px;"
                                onclick="toggleAllSubs(1)">å…¨é€‰</button>
                            <button class="btn btn-sm" style="font-size: 0.8em; padding: 2px 8px;"
                                onclick="toggleAllSubs(0)">åé€‰</button>
                        </div>
                    </div>
                    <div id="sub_selector" class="sub-selector-list">æ­£åœ¨è·å–è®¢é˜…...</div>
                </div>

                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">é«˜çº§æ­£åˆ™
                        (å¯é€‰)</label>
                    <input type="text" id="out_regex" placeholder="CCTV.* (éä¸“ä¸šäººå£«å»ºè®®ç•™ç©º)" value=".*">
                </div>

                <div class="form-group">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">EPG
                        èŠ‚ç›®é¢„å‘Š (å¯é€‰)</label>
                    <input type="text" id="out_epg" placeholder="EPG XML é“¾æ¥ (ä¾‹å¦‚: http://epg.51zmt.top:8000/api/xml/)">
                </div>

                <div class="form-group" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="out_include_suffix" checked
                        style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                    <label for="out_include_suffix"
                        style="margin: 0; opacity: 0.9; font-size: 0.95em; font-weight: 500; cursor: pointer;">åœ¨é¢‘é“ååæ˜¾ç¤ºè®¢é˜…æº
                        (ä¾‹å¦‚: CCTV1 (å«è§†ç²¾å“))</label>
                </div>

                <div class="form-group" style="margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="out_is_enabled" checked
                            style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                        <label for="out_is_enabled"
                            style="margin: 0; opacity: 0.9; font-size: 0.95em; cursor: pointer; font-weight: 500;">å¯ç”¨è¯¥èšåˆæº</label>
                    </div>
                </div>

                <div class="form-group"
                    style="display: flex; gap: 12px; align-items: center; margin-bottom: 16px; background: rgba(255,255,255,0.03); padding: 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.05);">
                    <div style="flex: 1;">
                        <select id="out_auto_update"
                            style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); color: #fff; border-radius: 8px; outline: none; font-size: 0.9em; cursor: pointer;">
                            <option value="0">è‡ªåŠ¨æ›´æ–°: å…³é—­ (æ‰‹åŠ¨åˆ·æ–°)</option>
                            <option value="60">è‡ªåŠ¨æ›´æ–°: æ¯ 1 å°æ—¶</option>
                            <option value="120">è‡ªåŠ¨æ›´æ–°: æ¯ 2 å°æ—¶</option>
                            <option value="240">è‡ªåŠ¨æ›´æ–°: æ¯ 4 å°æ—¶</option>
                            <option value="360">è‡ªåŠ¨æ›´æ–°: æ¯ 6 å°æ—¶</option>
                            <option value="480">è‡ªåŠ¨æ›´æ–°: æ¯ 8 å°æ—¶</option>
                            <option value="720">è‡ªåŠ¨æ›´æ–°: æ¯ 12 å°æ—¶</option>
                            <option value="1440">è‡ªåŠ¨æ›´æ–°: æ¯ 24 å°æ—¶</option>
                            <option value="10080">è‡ªåŠ¨æ›´æ–°: æ¯ 7 å¤©</option>
                        </select>
                    </div>
                    <div id="auto_visual_toggle_container"
                        style="flex: 1.2; display: flex; align-items: center; gap: 6px; padding-left: 10px; border-left: 1px solid rgba(255,255,255,0.1);">
                        <input type="checkbox" id="out_auto_visual"
                            style="width: 18px; height: 18px; cursor: pointer; margin: 0;">
                        <label for="out_auto_visual"
                            style="margin: 0; opacity: 0.8; font-size: 0.85em; cursor: pointer; line-height: 1.2;">æ›´æ–°åè‡ªåŠ¨æ‰§è¡Œæ·±åº¦æ£€æµ‹å¹¶å¯ç”¨/ç¦ç”¨é¢‘é“</label>
                    </div>
                </div>

                <div class="form-group" style="position: relative;">
                    <label
                        style="display: block; margin-bottom: 8px; opacity: 0.9; font-size: 0.95em; font-weight: 500;">å…³é”®å­—ç­›é€‰
                        (å›è½¦æŸ¥çœ‹ä¸‹æ–¹é¢„è§ˆ)</label>
                    <div id="tag_container" class="tag-container">
                        <div style="display: flex; flex-grow: 1; align-items: center; gap: 5px;">
                            <input type="text" id="tag_input" placeholder="å…³é”®å­—"
                                style="background: transparent; border: none; outline: none; flex-grow: 2; padding: 0;">
                        </div>
                    </div>
                    <div id="preview_window" class="preview-float"></div>
                </div>
            </div>

            <input type="hidden" id="edit_output_id">
            <div style="display: flex; gap: 10px; margin-bottom: 16px;">
                <button id="out_btn" class="btn" style="width: 100%;" onclick="saveOutput()">ç”Ÿæˆä¸“å± M3U èšåˆ
                    URL</button>
                <button id="out_cancel_btn" class="btn" style="display: none; background: rgba(255,255,255,0.1);"
                    onclick="cancelEditOutput()">å–æ¶ˆä¿®æ”¹</button>
            </div>
    </div>

    </section>
    </div>


    <div id="channel_modal" class="modal" onclick="if(event.target == this) closePreview()"
        style="display:none !important; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(12px); align-items: center; justify-content: center; padding: 20px; box-sizing: border-box;">

        <button id="back-to-top" class="btn" onclick="scrollToTop()"
            style="background: var(--primary); border-radius: 50%; width: 50px; height: 50px; font-size: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; position: fixed; bottom: 30px; right: 30px; z-index: 2001;">â†‘</button>

        <div class="glass-card"
            style="max-width: 800px; width: 100%; max-height: 90vh; position: relative; padding: 0; display: flex; flex-direction: column; overflow: hidden; margin: 0;">

            <div
                style="padding: 20px 24px; border-bottom: 1px solid var(--glass-border); display: flex; flex-direction: column; gap: 10px; background: rgba(30,30,45,0.98); z-index: 10; flex-shrink: 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 id="modal_title" style="margin: 0;">é¢‘é“é¢„è§ˆ</h2>
                    <span onclick="closePreview()"
                        style="cursor: pointer; font-size: 32px; line-height: 1; color: #fff; opacity: 0.8;">&times;</span>
                </div>
                <!-- å·¥å…·æ  -->
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <div style="display: flex; gap: 5px; flex-grow: 1;">
                        <input type="text" id="channel_search" placeholder="ğŸ” æœç´¢é¢‘é“åç§°..."
                            oninput="debounceSearchChannels()"
                            style="width: 100%; padding: 0 12px; font-size: 0.9em; min-width: 150px; height: 36px;">
                    </div>



                    <div id="check_options_container"
                        style="display: none; align-items: center; gap: 5px; margin-right: 5px;">
                        <label
                            style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #fff; opacity: 0.9;">
                            <input type="checkbox" id="auto_disable_check" style="width: 16px; height: 16px;">
                            <span style="font-size: 0.9em;">æ ¹æ®ç»“æœè‡ªåŠ¨å¯ç”¨/ç¦ç”¨</span>
                        </label>
                    </div>
                    <button id="check_btn" class="btn btn-sm toolbar-btn" onclick="checkPageConnectivity()"
                        style="background: #8b5cf6; display: none;">ğŸš€ å¿«é€Ÿæ£€æµ‹</button>
                    <button id="check_visual_btn" class="btn btn-sm toolbar-btn" onclick="checkVisualConnectivity()"
                        style="background: #ec4899; display: none;">ğŸ“º æ·±åº¦æ£€æµ‹</button>
                    <button id="refresh_epg_btn" class="btn btn-sm toolbar-btn" onclick="refreshEPG()"
                        style="background: #10b981; display: none;">ğŸ”„ åˆ·æ–°èŠ‚ç›®è¡¨</button>

                    <!-- æ‰¹é‡é€‰æ‹©å’Œæ“ä½œ -->
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-sm btn-outline toolbar-btn" onclick="toggleSelectAll(true)"
                            id="sel_all_btn" style="display: none;">å…¨é€‰</button>
                        <button class="btn btn-sm btn-outline toolbar-btn" onclick="invertSelection()" id="sel_inv_btn"
                            style="display: none;">åé€‰</button>
                        <button class="btn btn-sm toolbar-btn" onclick="selectByStatus(true)"
                            style="background: rgba(16, 185, 129, 0.2); display: none;"
                            id="sel_enabled_btn">å…¨é€‰å¯ç”¨</button>
                        <button class="btn btn-sm toolbar-btn" onclick="selectByStatus(false)"
                            style="background: rgba(239, 68, 68, 0.2); display: none;"
                            id="sel_disabled_btn">å…¨é€‰ç¦ç”¨</button>
                    </div>

                    <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2); margin: 0 5px; display: none;"
                        id="batch_sep"></div>

                    <button class="btn btn-sm toolbar-btn" onclick="batchSetStatus(true)"
                        style="background: #059669; display: none;" id="batch_enable_btn">å¯ç”¨é€‰ä¸­</button>
                    <button class="btn btn-sm toolbar-btn" onclick="batchSetStatus(false)"
                        style="background: #b91c1c; display: none;" id="batch_disable_btn">ç¦ç”¨é€‰ä¸­</button>
                </div>
            </div>

            <!-- æ»šåŠ¨ä¸»ä½“ -->
            <div id="channel_list_container" onscroll="handleModalScroll(this)"
                style="padding: 0 24px 24px; overflow-y: auto; flex-grow: 1;">
                <div id="channel_list">åŠ è½½ä¸­...</div>
            </div>

            <div
                style="padding: 16px; border-top: 1px solid var(--glass-border); display: flex; justify-content: space-between; align-items: center; background: rgba(30,30,45,0.98); flex-shrink: 0;">
                <div id="preview_stats" style="font-size: 0.9em; opacity: 0.8;">
                    å…± 0 ä¸ªé¢‘é“ / å·²å¯ç”¨ 0 ä¸ª
                </div>
                <button class="btn" onclick="closePreview()" style="background: rgba(255,255,255,0.1);">å…³é—­é¢„è§ˆ</button>
            </div>
        </div>
    </div>

    <div id="status"></div>
    <div id="toast-container"></div>

    <script>
        window.previewDebounceTimer = null;
        window.searchDebounceTimer = null;
        let currentSubTab = 'normal';

        function switchSubTab(mode) {
            currentSubTab = mode;
            const tabNormal = document.getElementById('tab_normal');
            const tabGit = document.getElementById('tab_git');
            const uaGroup = document.getElementById('ua_form_group');
            const urlInput = document.getElementById('sub_url');

            if (mode === 'normal') {
                tabNormal.classList.add('active');
                tabGit.classList.remove('active');
                uaGroup.style.display = 'block';
                urlInput.placeholder = "M3U URL (å¤šä¸ªåœ°å€è¯·ç”¨è‹±æ–‡é€—å·éš”å¼€)";
            } else {
                tabGit.classList.add('active');
                tabNormal.classList.remove('active');
                uaGroup.style.display = 'none';
                urlInput.placeholder = "Git ä»“åº“ URL (ä¾‹å¦‚: https://github.com/YueChan/Live.git)";
            }
        }

        function debounceUpdatePreview() {
            clearTimeout(window.previewDebounceTimer);
            window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
        }

        function debounceSearchChannels() {
            clearTimeout(window.searchDebounceTimer);
            window.searchDebounceTimer = setTimeout(searchChannels, 300);
        }

        function formatDate(isoStr) {
            if (!isoStr) return 'ä»æœªæ›´æ–°';
            // åç«¯ç”¨çš„æ˜¯ UTCã€‚æµè§ˆå™¨éœ€è¦è½¬æˆæœ¬åœ°æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
            const dateStr = isoStr.endsWith('Z') ? isoStr : isoStr + 'Z';
            const d = new Date(dateStr);
            return d.toLocaleString('zh-CN', { hour12: false });
        }

        // ... (fetchSubs æ²¡å˜) ...

        let currentChannels = [];
        let filteredChannels = [];
        let renderOffset = 0;
        const RENDER_SIZE = 100;

        // å¤šé€‰çŠ¶æ€
        window.selectedChannelIds = new Set();

        function prepareModal(titleText, showCheckBtn = false) {
            const modal = document.getElementById('channel_modal');
            const title = document.getElementById('modal_title');
            const list = document.getElementById('channel_list');
            const container = document.getElementById('channel_list_container');
            const searchInput = document.getElementById('channel_search');

            // åˆ‡æ¢æ£€æµ‹æŒ‰é’®
            const checkBtn = document.getElementById('check_btn');
            const checkVisualBtn = document.getElementById('check_visual_btn');
            const checkOptions = document.getElementById('check_options_container');
            const refreshBtn = document.getElementById('refresh_epg_btn');

            // æ‰¹é‡æŒ‰é’®
            const selAllBtn = document.getElementById('sel_all_btn');
            const selInvBtn = document.getElementById('sel_inv_btn');
            const selEnBtn = document.getElementById('sel_enabled_btn');
            const selDisBtn = document.getElementById('sel_disabled_btn');
            const batchEnBtn = document.getElementById('batch_enable_btn');
            const batchDisBtn = document.getElementById('batch_disable_btn');
            const batchSep = document.getElementById('batch_sep');

            const displayStyle = showCheckBtn ? 'block' : 'none';
            if (checkBtn) checkBtn.style.display = displayStyle;
            if (checkVisualBtn) checkVisualBtn.style.display = displayStyle;
            if (checkOptions) checkOptions.style.display = showCheckBtn ? 'flex' : 'none';
            if (refreshBtn) refreshBtn.style.display = displayStyle;

            if (selAllBtn) selAllBtn.style.display = displayStyle;
            if (selInvBtn) selInvBtn.style.display = displayStyle;
            if (selEnBtn) selEnBtn.style.display = displayStyle;
            if (selDisBtn) selDisBtn.style.display = displayStyle;
            if (batchEnBtn) batchEnBtn.style.display = displayStyle;
            if (batchDisBtn) batchDisBtn.style.display = displayStyle;
            if (batchSep) batchSep.style.display = displayStyle;

            title.innerText = titleText;
            list.innerHTML = 'æ­£åœ¨åŠ è½½...';
            searchInput.value = ''; // é‡ç½®æœç´¢

            // åˆ·æ–°èŠ‚ç›®è¡¨æŒ‰é’®
            const refreshEpgBtn = document.getElementById('refresh_epg_btn');
            if (refreshEpgBtn) {
                refreshEpgBtn.style.display = (showCheckBtn && window.currentEPGUrl) ? 'block' : 'none';
            }

            modal.style.setProperty('display', 'flex', 'important');
            document.body.style.overflow = 'hidden';
            container.scrollTop = 0;
            renderOffset = 0;
            window.selectedChannelIds.clear(); // é‡ç½®é€‰æ‹©
        }

        async function viewChannels(id, name, epgUrl = null) {
            window.currentEPGUrl = null; // å•ä¸ªæŸ¥çœ‹å¿½ç•¥è®¢é˜… EPG
            prepareModal(`é¢„è§ˆ: ${name}`);
            try {
                const res = await fetch(`/subscriptions/${id}/channels`);
                const data = await res.json();
                // æ‰‹åŠ¨æ·»åŠ æ¥æº
                currentChannels = data.map(c => ({ ...c, source: name }));
                filteredChannels = currentChannels;
                renderBaseTable(document.getElementById('channel_list'));
            } catch (err) {
                document.getElementById('channel_list').innerHTML = 'åŠ è½½å¤±è´¥: ' + err.message;
            }
        }

        async function viewOutputPreview(slug, name) {
            window.currentEPGUrl = null;

            // ä»å…¨å±€ allOutputs æ‰¾é…ç½®
            const out = allOutputs.find(o => o.slug === slug);
            if (out) window.currentEPGUrl = out.epg_url;

            prepareModal(`é¢„è§ˆèšåˆ: ${name}`, true); // ä¼  true æ˜¾ç¤ºæ£€æµ‹æŒ‰é’®

            if (!out) {
                document.getElementById('channel_list').innerHTML = 'æ— æ³•æ‰¾åˆ°èšåˆé…ç½®ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
                return;
            }

            try {
                // è§£æé…ç½®
                let keywords = [];
                try {
                    const parsed = JSON.parse(out.keywords || "[]");
                    parsed.forEach(k => {
                        if (typeof k === 'string') keywords.push({ value: k, group: '' });
                        else keywords.push(k);
                    });
                } catch (e) { }

                const subIds = JSON.parse(out.subscription_ids || "[]");

                const payload = {
                    subscription_ids: subIds,
                    keywords: keywords,
                    filter_regex: out.filter_regex
                };

                const res = await fetch('/outputs/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await res.json();

                // æŠŠç»“æœé“ºå¹³å¹¶å»é‡ï¼ˆé¿å…ä¸€ä¸ªé¢‘é“åŒ¹é…å¤šä¸ªå…³é”®å­—å¯¼è‡´å¤šæ¬¡å‡ºç°ï¼‰
                const seenIds = new Set();
                let flatChannels = [];
                for (const [key, list] of Object.entries(data)) {
                    list.forEach(c => {
                        if (!seenIds.has(c.id)) {
                            seenIds.add(c.id);
                            flatChannels.push(c);
                        }
                    });
                }

                currentChannels = flatChannels;
                filteredChannels = flatChannels;
                renderBaseTable(document.getElementById('channel_list'), true);
            } catch (err) {
                document.getElementById('channel_list').innerHTML = 'é¢„è§ˆåŠ è½½å¤±è´¥: ' + err.message;
            }
        }

        function searchChannels() {
            const query = document.getElementById('channel_search').value.toLowerCase().trim();
            if (!query) {
                filteredChannels = currentChannels;
            } else {
                filteredChannels = currentChannels.filter(c => c.name.toLowerCase().includes(query) || c.group.toLowerCase().includes(query));
            }
            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
        }

        function renderBaseTable(list, showActions = false) {
            window.lastRenderShowActions = showActions; // è®°å½•çŠ¶æ€ï¼Œæ–¹ä¾¿é‡ç»˜
            if (filteredChannels.length === 0) {
                list.innerHTML = '<p style="text-align:center; padding: 20px;">æš‚æ— åŒ¹é…å†…å®¹</p>';
                return;
            }

            list.innerHTML = `
                <table class="channel-table-container" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <thead>
                        <tr style="text-align: left; border-bottom: 2px solid var(--primary);">
                            ${showActions ? '<th style="padding: 10px; width: 30px;"><input type="checkbox" id="master_checkbox" onclick="toggleSelectAll(this.checked)"></th>' : ''}
                            <th style="padding: 10px; width: 60px;">Logo</th>
                            <th style="padding: 10px;">åç§°</th>
                            <th style="padding: 10px;">tvg-id</th>
                            ${window.currentEPGUrl ? '<th style="padding: 10px;">å½“å‰èŠ‚ç›®</th>' : ''}
                            <th style="padding: 10px;">åˆ†ç»„</th>
                            ${showActions ? '<th style="padding: 10px;">æ¥æº</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 100px;">å¯ç”¨æ€§</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 80px;">é¢„è§ˆ</th>' : ''}
                            ${showActions ? '<th style="padding: 10px; width: 80px;">æ“ä½œ</th>' : ''}
                        </tr>
                    </thead>
                    <tbody id="channel_tbody"></tbody>
                </table>
                <div id="load_more_container" style="text-align: center; padding: 20px;">
                    <button class="btn" style="min-width: 200px;" onclick="renderNextBatch()">æŸ¥çœ‹æ›´å¤š (å‰©ä½™ ${filteredChannels.length} æ¡)</button>
                </div>
            `;
            renderNextBatch();
            updatePreviewStats();
        }



        function renderNextBatch() {
            const list = document.getElementById('channel_tbody');
            const end = Math.min(renderOffset + RENDER_SIZE, filteredChannels.length);
            const batch = filteredChannels.slice(renderOffset, end);

            const html = batch.map(c => {
                let statusHtml = '<span style="opacity: 0.3;">-</span>';
                if (c.status !== undefined) {
                    if (c.status) {
                        statusHtml = `<span style="color: #10b981; font-size: 0.85em;">âœ… ${c.latency}ms</span>`;
                    } else {
                        statusHtml = `<span style="color: #ef4444; font-size: 0.85em;" title="${c.error || 'æœªçŸ¥'}">âŒ å¤±è´¥</span>`;
                    }
                } else if (c.checking) {
                    statusHtml = `<span style="color: #fbbf24; font-size: 0.85em;">â³ æ£€æµ‹ä¸­...</span>`;
                }

                // æ·±åº¦æ£€æµ‹ HTML
                let visualHtml = '';
                if (window.lastRenderShowActions) {
                    const image = c.visualImage || c.check_image;
                    const error = c.visualError || c.check_error;
                    const date = c.check_date;

                    let dateHtml = '';
                    if (date) {
                        // åç«¯è¿”å›çš„æ˜¯ UTC iso å­—ç¬¦ä¸²ï¼Œå‰ç«¯ new Date(date) ä¼šç”±äºç¼º Z è€ŒæŒ‰æœ¬åœ°æ—¶é—´è§£æ
                        // å¼ºåˆ¶åŠ  Z ç¡®ä¿æŒ‰ UTC è§£æï¼Œæ¶ˆé™¤ 8 å°æ—¶åç§»
                        const dateObj = new Date(date.endsWith('Z') ? date : date + 'Z');
                        const now = new Date();
                        const mins = Math.floor((now - dateObj) / 60000);
                        let timeStr = mins < 60 ? `${mins}åˆ†å‰` : (mins < 1440 ? `${Math.floor(mins / 60)}æ—¶å‰` : `${Math.floor(mins / 1440)}å¤©å‰`);

                        // å¢åŠ å…·ä½“æ ¼ç‚¹çš„æ—¶åˆ†æ˜¾ç¤ºï¼Œæ–¹ä¾¿æ ¸å¯¹
                        const hhmm = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                        dateHtml = `<div style="font-size: 0.75em; opacity: 0.5; margin-top: 2px;">ä¸Šæ¬¡æ£€æµ‹: ${timeStr} <small>(${hhmm})</small></div>`;
                    }

                    if (c.visualStatus === 'loading') {
                        visualHtml = `<td style="padding: 10px; font-size: 0.85em;">ğŸ”„ æ£€æµ‹ä¸­...</td>`;
                    } else if ((c.visualStatus === 'ok' || !c.visualStatus) && image) {
                        visualHtml = `<td style="padding: 10px;">
                            <img src="${image}" style="height: 40px; cursor: pointer;" onclick="window.open('${image}')" title="ç‚¹å‡»æ”¾å¤§">
                            ${dateHtml}
                        </td>`;
                    } else if (c.visualStatus === 'error' || error) {
                        visualHtml = `<td style="padding: 10px;">
                            <div style="color: #ef4444; font-size: 0.8em;" title="${error || 'æ£€æµ‹å¤±è´¥'}">âŒ æ— ç”»é¢</div>
                            ${dateHtml}
                        </td>`;
                    } else {
                        visualHtml = `<td style="padding: 10px; font-size: 0.8em; opacity: 0.5;">-</td>`;
                    }
                }

                return `
                <tr style="border-bottom: 1px solid var(--glass-border); ${c.is_enabled === false ? 'opacity: 0.5; background: rgba(0,0,0,0.2);' : ''}">
                    ${window.lastRenderShowActions ? `<td style="padding: 10px;"><input type="checkbox" class="ch-checkbox" data-id="${c.id}" ${window.selectedChannelIds.has(c.id) ? 'checked' : ''} onchange="toggleChannelSelection(${c.id}, this.checked)"></td>` : ''}
                    <td id="logo_${renderOffset}_${batch.indexOf(c)}" style="padding: 10px;">${c.logo ? `<img src="${c.logo}" style="height:30px; border-radius:4px" onerror="this.style.display='none'">` : ''}</td>
                    <td style="padding: 10px;">${c.name}</td>
                    <td style="padding: 10px; font-size: 0.8em; opacity: 0.6;">${c.tvg_id || '-'}</td>
                    ${window.currentEPGUrl ? `
                    <td id="epg_${renderOffset}_${batch.indexOf(c)}" style="padding: 10px; font-size: 0.85em; color: #a5b4fc;">
                        â³ åŠ è½½ä¸­...
                    </td>` : ''}
                    <td style="padding: 10px;">${c.group || 'é»˜è®¤'}</td>
                    ${window.lastRenderShowActions ? `<td style="padding: 10px; font-size: 0.85em; opacity: 0.7;">${c.source || 'æœªçŸ¥'}</td>` : ''}
                    ${window.lastRenderShowActions ? `<td style="padding: 10px;">${statusHtml}</td>` : ''}
                    ${visualHtml}
                    ${window.lastRenderShowActions ? `
                    <td style="padding: 10px;">
                        <button class="btn btn-sm" 
                            style="background: ${c.is_enabled !== false ? '#ef4444' : '#10b981'}; padding: 4px 8px; font-size: 0.8em;"
                            onclick="toggleChannel(${c.id})">
                            ${c.is_enabled !== false ? 'ç¦ç”¨' : 'å¯ç”¨'}
                        </button>
                    </td>` : ''}
                </tr>
            `}).join('');

            if (renderOffset === 0) {
                list.innerHTML = html;
            } else {
                list.insertAdjacentHTML('beforeend', html);
            }

            // æ‰¹é‡åŠ è½½ EPG (é˜²å¡æ­»)
            if (window.currentEPGUrl) {
                batch.forEach((c, idx) => {
                    enqueueEpgLoad(window.currentEPGUrl, c.tvg_id, c.name, `epg_${renderOffset}_${idx}`, c.logo, c.id);
                });
            }

            renderOffset = end;

            // æ›´æ–°â€œåŠ è½½æ›´å¤šâ€æŒ‰é’®
            const btnContainer = document.getElementById('load_more_container');
            if (renderOffset >= filteredChannels.length) {
                btnContainer.style.display = 'none';
            } else {
                btnContainer.style.display = 'block';
                btnContainer.querySelector('button').innerText = `æŸ¥çœ‹æ›´å¤š (å‰©ä½™ ${filteredChannels.length - renderOffset} æ¡)`;
            }
        }

        // EPG æ€§èƒ½ä¼˜åŒ–
        window.epgCache = new Map(); // ä¼šè¯çº§ç¼“å­˜
        const pendingEpgRequests = new Map(); // è¯·æ±‚å»é‡

        async function loadChannelEPG(epgUrl, tvgId, tvgName, cellId, currentLogo, channelId) {
            const cell = document.getElementById(cellId);
            if (!cell) return;

            try {
                let isRefresh = !!window.forceRefreshEPG;
                if (window.refreshSelectedOnly && channelId) {
                    isRefresh = window.selectedChannelIds.has(channelId);
                }

                // åˆå¹¶/å»é‡ Key
                const dedupeKey = `${epgUrl}_${tvgId}_${tvgName}_${isRefresh}`;

                // 1. æ£€æŸ¥ç¼“å­˜
                if (!isRefresh && window.epgCache.has(dedupeKey)) {
                    applyEpgData(cell, window.epgCache.get(dedupeKey), cellId);
                    return;
                }

                // 2. æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒè¯·æ±‚åœ¨å¤„ç†
                if (pendingEpgRequests.has(dedupeKey)) {
                    const data = await pendingEpgRequests.get(dedupeKey);
                    applyEpgData(cell, data, cellId);
                    return;
                }

                // 3. å‘èµ·è¯·æ±‚
                const fetchPromise = (async () => {
                    const url = `/api/epg/current?epg_url=${encodeURIComponent(epgUrl)}&tvg_id=${encodeURIComponent(tvgId || '')}&tvg_name=${encodeURIComponent(tvgName || '')}&current_logo=${encodeURIComponent(currentLogo || '')}&refresh=${isRefresh}`;
                    const res = await fetch(url);
                    return await res.json();
                })();

                pendingEpgRequests.set(dedupeKey, fetchPromise);

                const data = await fetchPromise;
                window.epgCache.set(dedupeKey, data);
                pendingEpgRequests.delete(dedupeKey);

                applyEpgData(cell, data, cellId);
            } catch (e) {
                if (cell) {
                    cell.innerText = 'åŠ è½½å¤±è´¥';
                    cell.style.color = '#f87171';
                    cell.title = e.message;
                    console.error("EPG Load Error:", e);
                }
            }
        }

        function applyEpgData(cell, data, cellId) {
            cell.innerText = data.program || 'æ— èŠ‚ç›®ä¿¡æ¯';
            if (data.program && data.program !== 'No Program Info') {
                cell.style.color = '#34d399';
                cell.style.opacity = '1';
            } else {
                cell.style.opacity = '0.5';
            }

            // æ›´æ–°å°æ ‡é€»è¾‘
            if (data.logo) {
                const logoCellId = cellId.replace('epg_', 'logo_');
                const logoCell = document.getElementById(logoCellId);
                if (logoCell) {
                    const img = logoCell.querySelector('img');
                    if (!img || img.style.display === 'none') {
                        logoCell.innerHTML = `<img src="${data.logo}" style="height:30px; border-radius:4px">`;
                    }
                }
            }
        }

        // EPG è¯·æ±‚é˜Ÿåˆ— (é˜²å¡æ­»)
        const epgQueue = [];
        let activeEpgRequests = 0;
        const MAX_EPG_CONCURRENCY = 10;

        function enqueueEpgLoad(...args) {
            epgQueue.push(args);
            processEpgQueue();
        }

        async function processEpgQueue() {
            if (activeEpgRequests >= MAX_EPG_CONCURRENCY || epgQueue.length === 0) return;

            const args = epgQueue.shift();
            activeEpgRequests++;
            try {
                await loadChannelEPG(...args);
            } finally {
                activeEpgRequests--;
                setTimeout(processEpgQueue, 10);
            }
        }

        async function refreshEPG() {
            if (!window.currentEPGUrl) return;

            if (window.selectedChannelIds.size === 0) {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            const btn = document.getElementById('refresh_epg_btn');
            btn.innerText = 'æ­£åœ¨æ›´æ–°...';
            btn.disabled = true;

            // window.forceRefreshEPG = true; // ä¸å†å…¨éƒ¨å¼ºåˆ¶
            window.refreshSelectedOnly = true;

            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            window.refreshSelectedOnly = false;

            btn.innerText = 'ğŸ”„ åˆ·æ–°èŠ‚ç›®è¡¨';
            btn.disabled = false;
        }

        async function checkPageConnectivity() {
            // ç¡®å®šæ£€æµ‹ç›®æ ‡
            let targetChannels = [];
            if (window.selectedChannelIds.size > 0) {
                targetChannels = filteredChannels.filter(c => window.selectedChannelIds.has(c.id));
            } else {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            if (targetChannels.length === 0) return;

            const confirmMsg = `å³å°†æ£€æµ‹é€‰ä¸­çš„ ${targetChannels.length} ä¸ªé¢‘é“çš„è¿é€šæ€§ (è€—æ—¶è¾ƒé•¿)ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ`;
            if (targetChannels.length > 500 && !confirm(confirmMsg)) return;

            // æ ‡è®°æ£€æµ‹ä¸­
            targetChannels.forEach(c => c.checking = true);

            // ç«‹å³æ¸²æŸ“åŠ è½½åŠ¨ç”»
            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            // åˆ†æ‰¹å¤„ç† (æ¯æ‰¹ 50)
            const chunkSize = 50;
            for (let i = 0; i < targetChannels.length; i += chunkSize) {
                const chunk = targetChannels.slice(i, i + chunkSize);
                // å‘é€å¸¦ ID çš„åˆ—è¡¨
                const items = chunk.map(c => ({ id: c.id, url: c.url }));

                try {
                    const res = await fetch('/check-connectivity', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ items: items })
                    });
                    const results = await res.json();

                    results.forEach(r => {
                        // ç®€å•é€šè¿‡ URL åŒ¹é…
                        chunk.filter(c => c.url === r.url).forEach(c => {
                            c.checking = false;
                            c.status = r.status;
                            c.latency = r.latency;
                            c.error = r.error;
                        });
                    });

                } catch (err) {
                    console.error("Check failed for batch", err);
                    chunk.forEach(c => { c.checking = false; c.error = "Check Failed"; });
                }

                renderOffset = 0;
                renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
            }
        }

        async function checkVisualConnectivity() {
            const btn = document.getElementById('check_visual_btn');

            // å¦‚æœæ­£åœ¨æ£€æŸ¥ï¼Œè®¾ç½®æ ‡å¿—ä¸º false ä»¥å–æ¶ˆ
            if (window.isVisualChecking) {
                window.isVisualChecking = false;
                btn.innerText = "â³ æ­£åœ¨å–æ¶ˆ...";
                btn.disabled = true;
                return;
            }

            if (filteredChannels.length === 0) return;

            // 1. æŸ¥æ‰¾å“ªäº›æ˜¯è¿˜æ²¡æ£€æµ‹è¿‡çš„
            const freshThreshold = 30 * 60 * 1000;
            const now = new Date();

            // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­é¢‘é“æ˜¯å¦å·²ç»æœ‰äº†â€œæ–°é²œâ€çš„æ£€æµ‹ç»“æœ
            const isFreshlyFinished = (c) => {
                if (c.visualStatus) return true; // æœ¬è½®æ£€æµ‹è¿‡çš„
                if (!c.check_date) return false; // æ ¹æœ¬æ²¡æ£€æµ‹è¿‡

                try {
                    // å…¼å®¹å„ç§æ—¥æœŸæ ¼å¼ï¼Œç¡®ä¿è§£ææ­£ç¡®
                    const dateStr = c.check_date.endsWith('Z') ? c.check_date : c.check_date.includes('+') ? c.check_date : c.check_date + 'Z';
                    const dateObj = new Date(dateStr);
                    return (now - dateObj) < freshThreshold;
                } catch (e) {
                    return false;
                }
            };

            const pendingChannels = filteredChannels.filter(c => !isFreshlyFinished(c));
            const completedCount = filteredChannels.length - pendingChannels.length;

            let targets = filteredChannels;
            if (completedCount > 0 && pendingChannels.length > 0) {
                // å¦‚æœæœ‰æ–°é²œç»“æœï¼Œæç¤ºæ˜¯å¦è·³è¿‡
                if (confirm(`å½“å‰åˆ—è¡¨å…± ${filteredChannels.length} ä¸ªé¢‘é“ï¼š\n- 30åˆ†é’Ÿå†…å·²æœ‰ç»“æœ: ${completedCount} ä¸ª\n- å¾…æ£€æµ‹/ä¸Šæ¬¡å¤±è´¥: ${pendingChannels.length} ä¸ª\n\næ˜¯å¦ä»…æ£€æµ‹â€œå¾…æ£€æµ‹/ä¸Šæ¬¡å¤±è´¥â€çš„é¢‘é“ï¼Ÿ\n(ç¡®å®šï¼šæ–­ç‚¹ç»­ä¼ ï¼› å–æ¶ˆï¼šå…¨éƒ¨é‡æ–°æ£€æµ‹)`)) {
                    targets = pendingChannels;
                }
            } else if (pendingChannels.length === 0 && filteredChannels.length > 0) {
                // æ‰€æœ‰éƒ½æ²¡å˜åŠ¨ï¼Œæç¤ºå…¨éƒ¨é‡æµ‹
                if (!confirm(`æ‰€æœ‰ ${filteredChannels.length} ä¸ªé¢‘é“åœ¨ 30 åˆ†é’Ÿå†…éƒ½å·²æ£€æµ‹è¿‡ï¼Œæ˜¯å¦è¦å…¨éƒ¨é‡æ–°æ£€æµ‹ï¼Ÿ`)) {
                    return;
                }
            }

            const count = targets.length;
            const confirmMsg = `å³å°†å¯¹ ${count} ä¸ªé¢‘é“è¿›è¡Œæ·±åº¦æ£€æµ‹ï¼ˆæˆªå›¾ï¼‰ã€‚\nè¿™å°†ä¼šéå¸¸è€—æ—¶ï¼ˆæ¯ä¸ªé¢‘é“çº¦ 3-5 ç§’ï¼‰ã€‚\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`;
            if (count > 20 && !confirm(confirmMsg)) return;

            window.isVisualChecking = true;
            btn.disabled = false;
            btn.innerText = "ğŸ›‘ å–æ¶ˆæ£€æµ‹";
            const originalBg = btn.style.background;
            btn.style.background = "#ef4444";

            const autoDisable = document.getElementById('auto_disable_check').checked;

            // åˆå§‹æ ‡è®°ä¸º loading (ä»…é’ˆå¯¹æœ¬æ¬¡è¦æ£€æµ‹çš„ç›®æ ‡)
            targets.forEach(c => c.visualStatus = 'loading');
            renderOffset = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            // åˆ†æ‰¹å¤„ç† (æ·±åº¦æ£€æµ‹è¦æ…¢ç‚¹)
            const chunkSize = 5;
            let finishedInThisSession = 0;

            for (let i = 0; i < targets.length; i += chunkSize) {
                if (!window.isVisualChecking) break;

                const chunk = targets.slice(i, i + chunkSize);
                const items = chunk.map(c => ({ id: c.id, url: c.url }));

                // æ›´æ–°æŒ‰é’®è¿›åº¦
                btn.innerText = `ğŸ›‘ å–æ¶ˆ (${finishedInThisSession}/${count})`;

                try {
                    const res = await fetch('/check-stream-visual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ items: items, auto_disable: autoDisable })
                    });
                    const results = await res.json();

                    results.forEach(r => {
                        const match = chunk.find(c => c.id === r.id);
                        if (match) {
                            finishedInThisSession++;
                            if (r.status) {
                                match.visualStatus = 'ok';
                                match.visualImage = r.image;
                                match.check_status = true;
                                match.check_image = r.image;
                                match.check_date = new Date().toISOString();
                            } else {
                                match.visualStatus = 'error';
                                match.visualError = r.error || 'æ£€æµ‹å¤±è´¥';
                                match.check_status = false;
                                match.check_image = null;

                                if (r.auto_disabled) {
                                    match.is_enabled = false;
                                }
                            }
                        }
                    });
                } catch (err) {
                    chunk.forEach(c => {
                        c.visualStatus = 'error';
                        c.visualError = "ç½‘ç»œé”™è¯¯";
                        c.check_status = false;
                        c.check_image = null;
                        finishedInThisSession++;
                    });
                }

                renderOffset = 0;
                renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);
            }

            // æ”¶å°¾
            const wasCancelled = !window.isVisualChecking;
            window.isVisualChecking = false;
            btn.disabled = false;
            btn.innerText = "ğŸ“º æ·±åº¦æ£€æµ‹";
            btn.style.background = originalBg;

            // å¦‚æœæ˜¯ä¸­é€”å–æ¶ˆçš„ï¼ŒæŠŠè¿˜æ²¡è½®åˆ°çš„ loading çŠ¶æ€æ¸…æ‰ï¼Œä¿ç•™å·²å®Œæˆçš„
            targets.forEach(c => {
                if (c.visualStatus === 'loading') {
                    c.visualStatus = null;
                }
            });

            renderOffset = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            if (!wasCancelled) {
                showStatus(`æ·±åº¦æ£€æµ‹å®Œæˆï¼Œå…±å¤„ç† ${finishedInThisSession} ä¸ªé¢‘é“ã€‚`);
            } else {
                showStatus(`æ£€æµ‹å·²ä¸­æ–­ï¼Œå·²ä¿å­˜ ${finishedInThisSession} ä¸ªç»“æœã€‚`);
            }
        }

        async function toggleChannel(id) {
            try {
                const res = await fetch(`/channels/${id}/toggle`, { method: 'POST' });
                if (!res.ok) throw new Error("æ“ä½œå¤±è´¥");
                const updated = await res.json();

                // æ›´æ–°æœ¬åœ°æ•°æ®
                const item = currentChannels.find(c => c.id === id);
                if (item) {
                    item.is_enabled = updated.is_enabled;
                    // å¼ºåˆ¶åˆ·è¡¨
                    renderOffset = 0;
                    renderBaseTable(document.getElementById('channel_list'), true);
                    document.getElementById('channel_list_container').scrollTop = 0;
                }
            } catch (err) {
                alert("æ“ä½œå¤±è´¥: " + err.message);
            }
        }

        async function fetchSubs() {
            const res = await fetch('/subscriptions/');
            const data = await res.json();

            // æ¸²æŸ“è®¢é˜…ç®¡ç†åˆ—è¡¨
            const list = document.getElementById('sub_list');
            list.innerHTML = data.map(s => {
                const statusColor = s.last_update_status && s.last_update_status.startsWith('Error') ? '#ef4444' : '#10b981';
                const opacity = s.is_enabled ? '1' : '0.5';
                const toggleText = s.is_enabled ? 'ç¦ç”¨' : 'å¯ç”¨';
                const toggleColor = s.is_enabled ? '#f59e0b' : '#10b981';

                return `
                <div id="sub_item_${s.id}" class="sub-item" style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--glass-border); padding-bottom: 8px; opacity: ${opacity};">
                    <div style="cursor: pointer; flex-grow: 1;" onclick="viewChannels(${s.id}, '${(s.name || s.url).replace(/'/g, "\\'")}', '${s.epg_url || ''}')">
                        <strong style="color: ${s.name ? 'inherit' : '#94a3b8'};">${s.name || 'æœªå‘½åè®¢é˜… (' + s.url.substring(0, 20) + '...)'}</strong>
                        ${!s.is_enabled ? '<span style="background: #64748b; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; margin-left: 8px;">å·²ç¦ç”¨</span>' : ''}
                        ${s.epg_url ? '<span style="background: #8b5cf6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; margin-left: 8px;">EPG</span>' : ''}
                        <br>
                        <small style="opacity: 0.6;">${s.url.substring(0, 50)}...</small>
                        <div style="font-size: 0.8em; margin-top: 4px; opacity: 0.8;">
                            ğŸ“… ${formatDate(s.last_updated)} 
                            <span style="color: ${statusColor}; margin-left: 8px;">
                                ${s.last_update_status || 'ç­‰å¾…æ›´æ–°'}
                            </span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-sm" style="background: ${toggleColor};" onclick="toggleSubActive(${s.id}, ${s.is_enabled})">${toggleText}</button>
                        <button class="btn btn-sm" style="background: var(--primary);" onclick="prepareEditSub(${s.id}, '${(s.name || "").replace(/'/g, "\\'")}', '${s.url}', '${s.user_agent}', ${s.auto_update_minutes || 0}, ${s.is_enabled})">ä¿®æ”¹</button>
                        <button class="btn btn-sm" style="background: #10b981;" onclick="refreshSub(${s.id})">åˆ·æ–°</button>
                        <button class="btn btn-sm" style="background: #3b82f6;" onclick="viewChannels(${s.id}, '${(s.name || s.url).replace(/'/g, "\\'")}', '${s.epg_url || ''}')">æŸ¥çœ‹</button>
                        <button class="btn btn-sm" style="background: #ef4444;" onclick="deleteSub(${s.id})">åˆ é™¤</button>
                    </div>
                </div>
            `}).join('') || 'æš‚æ— è®¢é˜…';

            // èšåˆé¡µé¢çš„è®¢é˜…é€‰æ‹© (ä»…æ˜¾ç¤ºå¯ç”¨çš„)
            const selector = document.getElementById('sub_selector');
            selector.innerHTML = data.filter(s => s.is_enabled).map(s => `
                <label class="sub-checkbox-item">
                    <input type="checkbox" name="selected_subs" value="${s.id}" onchange="debounceUpdatePreview()">
                    <span>${s.name || s.url}</span>
                </label>
            `).join('') || (data.length > 0 ? 'æ‰€æœ‰è®¢é˜…å‡å·²ç¦ç”¨' : 'è¯·å…ˆæ·»åŠ è®¢é˜…æº');
        }

        window._subLastScrollY = 0;
        function prepareEditSub(id, name, url, ua, autoMinutes, isEnabled) {
            window._subLastScrollY = window.scrollY; // è®°å½•ä½ç½®
            document.getElementById('sub_form_container').scrollIntoView({ behavior: 'smooth' });

            document.getElementById('edit_sub_id').value = id;
            document.getElementById('sub_is_enabled').value = isEnabled === undefined ? true : isEnabled;
            document.getElementById('sub_name').value = name;
            document.getElementById('sub_url').value = url;
            document.getElementById('sub_ua').value = ua;
            // è®¾ç½®è‡ªåŠ¨æ›´æ–°é¡¹
            document.getElementById('sub_auto_update').value = autoMinutes || 0;

            // è‡ªåŠ¨åˆ‡é¡µç­¾
            if (url.endsWith('.git') || url.includes('.git/') || (url.includes('github.com') && !url.includes('/raw/'))) {
                switchSubTab('git');
            } else {
                switchSubTab('normal');
            }

            document.getElementById('sub_form_title').innerText = 'ğŸ“ ä¿®æ”¹è®¢é˜…æº';
            document.getElementById('sub_btn').innerText = 'ä¿å­˜ä¿®æ”¹';
            document.getElementById('sub_cancel_btn').style.display = 'block';
            document.getElementById('sub_form_container').classList.add('edit-mode');

            // çªå‡ºæ˜¾ç¤º
            document.querySelectorAll('.sub-item').forEach(el => el.style.opacity = '0.4');
            document.getElementById(`sub_item_${id}`).style.opacity = '1';
        }

        function cancelEditSub() {
            if (window._subLastScrollY !== undefined) {
                window.scrollTo({ top: window._subLastScrollY, behavior: 'smooth' });
            }
            document.getElementById('edit_sub_id').value = '';
            document.getElementById('sub_name').value = '';
            document.getElementById('sub_url').value = '';
            document.getElementById('sub_ua').value = '';
            document.getElementById('sub_auto_update').value = '0';

            switchSubTab('normal');

            document.getElementById('sub_form_title').innerText = 'â• æ·»åŠ è®¢é˜…æº';
            document.getElementById('sub_btn').innerText = 'æ·»åŠ è®¢é˜…';
            document.getElementById('sub_cancel_btn').style.display = 'none';
            document.getElementById('sub_form_container').classList.remove('edit-mode');
            document.querySelectorAll('.sub-item').forEach(el => el.style.opacity = '1');
        }

        // å…³é”®å­—æ ‡ç­¾é€»è¾‘
        // é¢„æœŸæ ¼å¼: { value: 'k', group: 'g' }
        let keywords = [];

        document.getElementById('tag_input').addEventListener('keydown', handleTagInput);

        function handleTagInput(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const input = document.getElementById('tag_input');
                const val = input.value.trim();

                if (val) {
                    // å»é‡
                    const exists = keywords.some(k => k.value === val);
                    if (!exists) {
                        keywords.push({ value: val, group: '' });

                        // è‡ªåŠ¨åˆ‡åˆ°æ–°æ ‡ç­¾
                        activeKeyword = val;

                        // æ¸…ç©ºè¾“å…¥
                        input.value = '';
                        renderTags();

                        // é˜²æŠ–é¢„è§ˆ
                        clearTimeout(window.previewDebounceTimer);
                        window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
                    } else {
                        // é‡å¤çš„è¯æ¸…ç©ºè¾“å…¥æ¡†
                        input.value = '';
                    }
                }
            }
        }

        // é¢„è§ˆå…¨å±€çŠ¶æ€
        let lastPreviewData = {};
        let activeKeyword = null; // å­˜çš„æ˜¯å­—ç¬¦ä¸²

        function renderTags() {
            const container = document.getElementById('tag_container');
            const input = document.getElementById('tag_input');

            // åˆ æ‰æ—§æ ‡ç­¾
            container.querySelectorAll('.tag').forEach(el => el.remove());

            // æ„å»º HTML
            const tagsHtml = keywords.map(k => {
                const isActive = k.value === activeKeyword ? 'active-tag' : '';
                const display = k.group ? `${k.value} <span style="opacity:0.6; font-size:0.9em">â†’ ${k.group}</span>` : k.value;
                return `
                    <span class="tag ${isActive}" onclick="selectKeyword('${k.value.replace(/'/g, "\\'")}')">
                        ${display}
                        <span class="tag-remove" onclick="event.stopPropagation(); removeTag('${k.value.replace(/'/g, "\\'")}')">&times;</span>
                    </span>
                `;
            }).join('');

            // è¿˜åŸ HTML
            container.innerHTML = tagsHtml + `
                <div style="display: flex; flex-grow: 1; align-items: center; gap: 5px;">
                    <input type="text" id="tag_input" placeholder="å…³é”®å­—" value="${input.value}"
                        style="background: transparent; border: none; outline: none; flex-grow: 2; padding: 0;">
                </div>
            `;

            // é‡æ–°ç»‘äº‹ä»¶
            document.getElementById('tag_input').addEventListener('keydown', handleTagInput);
            document.getElementById('tag_input').focus();
        }

        function removeTag(val) {
            keywords = keywords.filter(k => k.value !== val);
            if (activeKeyword === val) {
                activeKeyword = keywords.length > 0 ? keywords[keywords.length - 1].value : null;
            }
            renderTags();
            // é˜²æŠ–
            clearTimeout(window.previewDebounceTimer);
            window.previewDebounceTimer = setTimeout(updateRealtimePreview, 300);
        }

        function selectKeyword(k) {
            activeKeyword = k;
            renderTags();
            renderSelectedPreview();
        }

        function updateKeywordGroup(val, newGroup) {
            const kObj = keywords.find(k => k.value === val);
            if (kObj) {
                kObj.group = newGroup.trim();
                renderTags(); // æ›´æ–°æ˜¾ç¤º
                // æ›´æ–°é¢„è§ˆæ ‡é¢˜

                // è§¦å‘é¢„è§ˆæ›´æ–°
                clearTimeout(window.previewDebounceTimer);
                window.previewDebounceTimer = setTimeout(updateRealtimePreview, 500);
            }
        }

        function renderSelectedPreview() {
            const previewWin = document.getElementById('preview_window');

            if (!activeKeyword || !lastPreviewData) {
                if (keywords.length === 0 && lastPreviewData && lastPreviewData["All"]) {
                    // æš‚ä¸”éšè—
                    previewWin.style.display = 'none';
                    return;
                }
                previewWin.style.display = 'none';
                return;
            }

            const kObj = keywords.find(k => k.value === activeKeyword);
            if (!kObj) {
                previewWin.style.display = 'none';
                return;
            }

            // æ‰¾æ•°æ®
            const displayKey = kObj.group ? `${kObj.value} â†’ ${kObj.group}` : kObj.value;

            // æ²¡é¢‘é“ä¹Ÿç»™å®ƒç”»ä¸ªå¤´
            renderPreviewGroup(kObj, lastPreviewData[displayKey] || []);
        }

        function renderPreviewGroup(kObj, channels) {
            const previewWin = document.getElementById('preview_window');
            if (!kObj) return;

            const key = kObj.value;
            const groupVal = kObj.group || '';

            const channelsHtml = (channels && channels.length > 0) ? channels.map(c => `
                    <div class="preview-item">
                        ${c.logo ? `<img src="${c.logo}" onerror="this.style.display='none'">` : '<div style="width:20px"></div>'}
                        <div style="flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            <strong>${c.name}</strong><br>
                            <small style="opacity: 0.8; font-size: 0.85em; color: #a5b4fc;">æ¥æº: ${c.source}</small>
                        </div>
                        <small style="opacity: 0.4; margin-left: 5px;">${c.group || 'é»˜è®¤'}</small>
                    </div>
                `).join('') : '<div style="opacity: 0.5; padding: 10px;">è¯¥æ ‡ç­¾ä¸‹æ²¡æœ‰åŒ¹é…çš„é¢‘é“</div>';

            const html = `
                <div id="preview-group-${key}" style="margin-top: 5px; border-left: 3px solid var(--primary); padding-left: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.03); display: flex; align-items: center; justify-content: space-between; padding-right: 10px;">
                    <div>
                        <small style="color: var(--primary); font-weight: bold; text-transform: uppercase;">${key}</small>
                        <span style="font-size: 0.8em; opacity: 0.5; margin-left: 5px;">åŒ¹é…: ${channels ? channels.length : 0}</span>
                    </div>
                    <input type="text" placeholder="è®¾ç½®åˆ†ç»„" value="${groupVal}" 
                        onchange="updateKeywordGroup('${key.replace(/'/g, "\\'")}', this.value)"
                        style="background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: 4px; padding: 2px 8px; width: 120px; font-size: 0.85em; color: #fff;">
                </div>
                ${channelsHtml}
            `;

            previewWin.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 5px;">
                    <span style="opacity: 0.7; font-size: 0.8em;">åŒ¹é…ä¸åˆ†ç»„è®¾ç½®:</span>
                    <span onclick="document.getElementById('preview_window').style.display='none'" 
                          style="cursor:pointer; font-size: 1.2em; line-height: 0.5; opacity: 0.8;">&times;</span>
                </div>
                ${html}`;
            previewWin.style.display = 'block';
        }

        // å¼¹çª—ç³»ç»Ÿ
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            let icon = 'â„¹ï¸';
            if (type === 'success') icon = 'âœ…';
            if (type === 'error') icon = 'âŒ';

            toast.innerHTML = `<span style="margin-right:8px">${icon}</span> ${message}`;

            container.appendChild(toast);

            // è‡ªåŠ¨ç§»é™¤
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s forwards';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // --- ç»“æŸ ---

        async function updateRealtimePreview() {
            const previewWin = document.getElementById('preview_window');
            const selectedSubs = Array.from(document.querySelectorAll('input[name="selected_subs"]:checked')).map(cb => parseInt(cb.value));

            if (selectedSubs.length === 0 && keywords.length === 0) {
                previewWin.style.display = 'none';
                return;
            }

            const data = {
                subscription_ids: selectedSubs,
                keywords: keywords,
                filter_regex: document.getElementById('out_regex').value || ".*"
            };

            try {
                const res = await fetch('/outputs/preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const groupedResults = await res.json();
                lastPreviewData = groupedResults;

                if (keywords.length > 0) {
                    // æ ¡éªŒå½“å‰æ ‡ç­¾æ˜¯å¦è¿˜æœ‰æ•ˆ
                    if (!activeKeyword || !keywords.some(k => k.value === activeKeyword)) {
                        activeKeyword = keywords[keywords.length - 1].value;
                    }
                } else {
                    activeKeyword = null;
                }

                renderTags();
                renderSelectedPreview();

            } catch (err) {
                console.error('é¢„è§ˆåŠ è½½å¤±è´¥:', err);
                previewWin.style.display = 'none';
            }
        }


        function closePreview() {
            const modal = document.getElementById('channel_modal');
            modal.style.setProperty('display', 'none', 'important');
            document.body.style.overflow = '';
        }

        function handleModalScroll(el) {
            const btt = document.getElementById('back-to-top');
            if (el.scrollTop > 600) {
                btt.style.display = 'flex';
            } else {
                btt.style.display = 'none';
            }
        }

        function scrollToTop() {
            document.getElementById('channel_list_container').scrollTo({ top: 0, behavior: 'smooth' });
        }

        async function deleteSub(id) {
            console.log('å°è¯•åˆ é™¤è®¢é˜…:', id);
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè®¢é˜…å—ï¼Ÿ')) return;
            // äºŒæ¬¡ç¡®è®¤
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šåˆ é™¤è®¢é˜…å°†ç§»é™¤ç›¸å…³æ•°æ®ï¼Œç¡®å®šå—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/subscriptions/${id}`, { method: 'DELETE' });
                if (res.ok) {
                    showStatus('åˆ é™¤æˆåŠŸ');
                    fetchSubs();
                } else {
                    const error = await res.text();
                    console.error('åˆ é™¤å¤±è´¥:', error);
                    alert('åˆ é™¤å¤±è´¥: ' + error);
                }
            } catch (err) {
                console.error('åˆ é™¤è¿‡ç¨‹ä¸­ç½‘ç»œé”™è¯¯:', err);
                alert('ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•è¿æ¥æœåŠ¡å™¨');
            }
        }

        function toggleAllSubs(mode) {
            const checkboxes = document.querySelectorAll('input[name="selected_subs"]');
            checkboxes.forEach(cb => {
                if (mode === 1) cb.checked = true;
                else cb.checked = !cb.checked;
            });
            debounceUpdatePreview();
        }

        async function addSubscription() {
            const editId = document.getElementById('edit_sub_id').value;
            const nameInput = document.getElementById('sub_name').value.trim();
            const urlInput = document.getElementById('sub_url').value;
            const uaInput = document.getElementById('sub_ua').value;
            const autoMinutes = parseInt(document.getElementById('sub_auto_update').value);


            const urls = urlInput.split(/[\n,]+/).map(u => u.trim()).filter(u => u);

            if (urls.length === 0) {
                alert("è¯·è¾“å…¥è‡³å°‘ä¸€ä¸ªè®¢é˜…åœ°å€");
                return;
            }

            if (editId) {
                // ä¿®æ”¹æ¨¡å¼ï¼šä»…å…è®¸ä¿®æ”¹å•ä¸ª URLï¼ˆæ‰¹é‡ä¿®æ”¹å¾ˆå¤æ‚ï¼‰
                if (urls.length > 1) {
                    showToast("ä¿®æ”¹æ¨¡å¼ä¸‹ä¸æ”¯æŒæ‰¹é‡è¾“å…¥ï¼Œè¯·åªä¿ç•™ä¸€ä¸ª URL", "error");
                    return;
                }
                await submitSingleSub(editId, nameInput, urls[0], uaInput, autoMinutes, 'PUT');
            } else {
                // æ·»åŠ æ¨¡å¼ï¼šæ”¯æŒæ‰¹é‡
                showStatus(`å‡†å¤‡æ·»åŠ  ${urls.length} ä¸ªè®¢é˜…...`);
                let successCount = 0;

                for (let i = 0; i < urls.length; i++) {
                    const u = urls[i];
                    // åç§°ç”Ÿæˆè§„åˆ™: "åç§°", "åç§°_2", "åç§°_3"...
                    let name = nameInput;
                    if (urls.length > 1 && nameInput) {
                        name = (i === 0) ? nameInput : `${nameInput}_${i + 1}`;
                    }

                    const ok = await submitSingleSub(null, name, u, uaInput, autoMinutes, 'POST');
                    if (ok) successCount++;
                }

                if (successCount > 0) {
                    showStatus(`æˆåŠŸæ·»åŠ  ${successCount} / ${urls.length} ä¸ªè®¢é˜…`);
                    fetchSubs();
                    cancelEditSub();
                }
            }
        }

        async function submitSingleSub(id, name, url, ua, autoMinutes, method) {
            const sub = {
                name: name,
                url: url,
                user_agent: ua,
                headers: "{}",
                auto_update_minutes: autoMinutes,
                is_enabled: document.getElementById('sub_is_enabled').value === 'false' ? false : true
            };

            const apiUrl = id ? `/subscriptions/${id}` : '/subscriptions/';

            try {
                const res = await fetch(apiUrl, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sub)
                });

                if (res.ok) {
                    if (method === 'PUT') {
                        showToast('ä¿®æ”¹æˆåŠŸ', 'success');
                        fetchSubs();
                        cancelEditSub();
                    }
                    return true;
                } else {
                    const error = await res.json();
                    const msg = error.detail || 'æœªçŸ¥é”™è¯¯';
                    console.error(`ä¿å­˜ ${url} å¤±è´¥:`, msg);
                    if (method === 'PUT') showToast('ä¿å­˜å¤±è´¥: ' + msg, 'error');
                    return false;
                }
            } catch (err) {
                console.error(`${url} çš„ç½‘ç»œé”™è¯¯:`, err);
                if (method === 'PUT') showToast('ç½‘ç»œè¿æ¥å¤±è´¥', 'error');
                return false;
            }
        }

        async function toggleSubActive(id, currentStatus) {
            // è·å–å½“å‰è®¢é˜…æ•°æ®
            const res = await fetch('/subscriptions/');
            const subs = await res.json();
            const sub = subs.find(s => s.id === id);
            if (!sub) return;

            sub.is_enabled = !currentStatus;

            const putRes = await fetch(`/subscriptions/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(sub)
            });

            if (putRes.ok) {
                showStatus(sub.is_enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨');
                fetchSubs();
            }
        }

        async function refreshSub(id) {
            showStatus('æ­£åœ¨æŠ“å–ä¸­...');
            const res = await fetch(`/subscriptions/${id}/refresh`, { method: 'POST' });
            if (res.ok) {
                const data = await res.json();
                showStatus(`åˆ·æ–°æˆåŠŸ: ${data.message}`);
            } else {
                showStatus('åˆ·æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ URL æˆ–ç½‘ç»œ');
            }
        }

        async function deleteOutput(id) {
            console.log('è§¦å‘åˆ é™¤èšåˆ:', id);
            if (!confirm('ç¡®å®šåˆ é™¤æ­¤èšåˆåˆ—è¡¨å—ï¼Ÿ')) return;
            // äºŒæ¬¡ç¡®è®¤
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦åˆ é™¤å—ï¼Ÿ')) return;

            try {
                const res = await fetch(`/outputs/${id}`, { method: 'DELETE' });
                if (res.ok) {
                    fetchOutputs();
                } else {
                    alert('åˆ é™¤å¤±è´¥');
                }
            } catch (err) {
                alert('æ“ä½œå¤±è´¥: ' + err.message);
            }
        }
        // æŒ‚åˆ° window é˜²æ­¢ä½œç”¨åŸŸå‡ºé—®é¢˜
        window.deleteOutput = deleteOutput;

        let allOutputs = [];

        window._outLastScrollY = 0;
        function prepareEditOutput(id) {
            window._outLastScrollY = window.scrollY; // è®°å½•ä½ç½®
            document.getElementById('outputs').scrollIntoView({ behavior: 'smooth' });

            const out = allOutputs.find(o => o.id === id);
            if (!out) return;

            document.getElementById('edit_output_id').value = out.id;
            document.getElementById('out_name').value = out.name;
            document.getElementById('out_slug').value = out.slug;
            document.getElementById('out_regex').value = out.filter_regex;
            document.getElementById('out_epg').value = out.epg_url || '';
            document.getElementById('out_include_suffix').checked = out.include_source_suffix !== false;
            document.getElementById('out_is_enabled').checked = out.is_enabled !== false;
            document.getElementById('out_auto_update').value = out.auto_update_minutes || 0;
            document.getElementById('out_auto_visual').checked = out.auto_visual_check || false;

            // è¿˜åŸå…³é”®å­—
            keywords = [];
            let parsedKeys = [];
            try {
                parsedKeys = JSON.parse(out.keywords || "[]");
            } catch (e) { parsedKeys = []; }

            parsedKeys.forEach(k => {
                if (typeof k === 'string') {
                    keywords.push({ value: k, group: '' });
                } else if (typeof k === 'object') {
                    keywords.push(k);
                }
            });

            renderTags();
            activeKeyword = null; // ä¿®æ”¹æ—¶ä¸è‡ªåŠ¨é€‰ä¸­æ ‡ç­¾

            // è¿˜åŸé€‰ä¸­çš„è®¢é˜…
            const subIds = JSON.parse(out.subscription_ids || "[]");
            document.querySelectorAll('input[name="selected_subs"]').forEach(cb => {
                cb.checked = subIds.includes(parseInt(cb.value));
            });

            // æ¢ UI
            document.getElementById('out_btn').innerText = 'ä¿å­˜ä¿®æ”¹';
            document.getElementById('out_cancel_btn').style.display = 'block';
            document.getElementById('out_name').focus();
        }

        function cancelEditOutput() {
            if (window._outLastScrollY !== undefined) {
                window.scrollTo({ top: window._outLastScrollY, behavior: 'smooth' });
            }
            document.getElementById('edit_output_id').value = '';
            document.getElementById('out_name').value = '';
            document.getElementById('out_slug').value = '';
            document.getElementById('out_regex').value = '.*';
            document.getElementById('out_epg').value = '';
            document.getElementById('out_include_suffix').checked = true;
            document.getElementById('out_is_enabled').checked = true; // é»˜è®¤å¯ç”¨
            document.getElementById('out_auto_update').value = 0; // é»˜è®¤ä¸è‡ªåŠ¨æ›´æ–°
            document.getElementById('out_auto_visual').checked = false;

            keywords = [];
            renderTags();
            activeKeyword = null;

            document.querySelectorAll('input[name="selected_subs"]').forEach(cb => cb.checked = false);

            document.getElementById('out_btn').innerText = 'ç”Ÿæˆä¸“å± M3U èšåˆ URL';
            document.getElementById('out_cancel_btn').style.display = 'none';
            document.getElementById('preview_window').style.display = 'none';
        }

        async function saveOutput() {
            const id = document.getElementById('edit_output_id').value;
            const name = document.getElementById('out_name').value;
            const slug = document.getElementById('out_slug').value;

            // é€‰ä¸­çš„è®¢é˜…
            const selectedSubs = Array.from(document.querySelectorAll('input[name="selected_subs"]:checked'))
                .map(cb => parseInt(cb.value));

            if (!name || !slug) {
                alert('è¯·å¡«å†™åç§°å’Œåç¼€');
                return;
            }

            const out = {
                name: name,
                slug: slug,
                filter_regex: document.getElementById('out_regex').value,
                keywords: JSON.stringify(keywords), // Assuming 'keywords' is the global variable for tags
                subscription_ids: JSON.stringify(selectedSubs),
                epg_url: document.getElementById('out_epg').value,
                include_source_suffix: document.getElementById('out_include_suffix').checked,
                is_enabled: document.getElementById('out_is_enabled').checked,
                auto_update_minutes: parseInt(document.getElementById('out_auto_update').value),
                auto_visual_check: document.getElementById('out_auto_visual').checked
            };

            const method = id ? 'PUT' : 'POST';
            const url = id ? `/outputs/${id}` : '/outputs/';

            const res = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(out)
            });

            if (res.ok) {
                showToast(id ? 'ä¿®æ”¹æˆåŠŸ' : 'åˆ—è¡¨ç”ŸæˆæˆåŠŸï¼', 'success');
                fetchOutputs();
                cancelEditOutput();
            } else {
                const err = await res.json();
                showToast('ä¿å­˜å¤±è´¥: ' + (err.detail || 'å¯èƒ½æ˜¯åç¼€å·²å­˜åœ¨'), 'error');
            }
        }

        async function refreshOutput(id) {
            showStatus('æ­£åœ¨åˆ·æ–°æ‰€æœ‰å…³è”è®¢é˜…...');
            try {
                const res = await fetch(`/outputs/${id}/refresh`, { method: 'POST' });
                if (res.ok) {
                    const data = await res.json();
                    showStatus('åˆ·æ–°å®Œæˆ');
                    console.log(data);
                    fetchOutputs();
                    fetchSubs(); // é¡ºå¸¦åˆ·ä¸‹çŠ¶æ€
                } else {
                    alert('åˆ·æ–°å¤±è´¥');
                }
            } catch (err) {
                alert('ç½‘ç»œé”™è¯¯: ' + err.message);
            }
        }

        async function fetchOutputs() {
            try {
                const res = await fetch('/outputs/');
                const data = await res.json();
                allOutputs = data; // å­˜å…¨å±€
                const list = document.getElementById('output_list');

                if (data.length === 0) {
                    list.innerHTML = 'æš‚æ— å·²åˆ›å»ºçš„èšåˆ';
                    return;
                }

                list.innerHTML = data.map(o => {
                    const statusColor = o.last_update_status && o.last_update_status.startsWith('Error') ? '#ef4444' : '#10b981';
                    const subIds = JSON.parse(o.subscription_ids || "[]");
                    return `
                    <div class="output-item-card ${o.is_enabled === false ? 'disabled-card' : ''}">
                        <div class="card-info">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <strong style="font-size: 1.1em; color: var(--primary);">${o.name}</strong>
                                ${o.is_enabled === false ? '<span style="font-size: 0.75em; background: #ef4444; color: #fff; padding: 2px 6px; border-radius: 4px;">å·²ç¦ç”¨</span>' : '<span style="font-size: 0.75em; background: #10b981; color: #fff; padding: 2px 6px; border-radius: 4px;">è¿è¡Œä¸­</span>'}
                            </div>
                            <div class="url-display" onclick="copyToClipboard('${window.location.origin}/m3u/${o.slug}')">
                                ${window.location.origin}/m3u/${o.slug}
                            </div>
                            <div style="font-size: 0.85em; opacity: 0.7; margin-top: 4px;">
                                <span>æ­£åˆ™: <code>${o.filter_regex || '.*'}</code></span>
                                <span style="margin-left: 10px;">â€¢ åŒ…å« ${subIds.length} ä¸ªæº</span>
                                ${o.auto_update_minutes > 0 ? `<span style="margin-left: 10px; color: #a5b4fc;">â€¢ ğŸ”„ æ¯${o.auto_update_minutes >= 60 ? o.auto_update_minutes / 60 + 'æ—¶' : o.auto_update_minutes + 'åˆ†'}åŒæ­¥</span>` : ''}
                            </div>
                            <div style="font-size: 0.8em; opacity: 0.5; margin-top: 4px;">
                                æœ€ååŒæ­¥: ${formatDate(o.last_updated)} ${o.last_update_status ? `(<span style="color: ${statusColor};">${o.last_update_status}</span>)` : ''}
                            </div>
                            <div style="font-size: 0.8em; opacity: 0.6; margin-top: 2px;">
                                ğŸ“¡ æœ€è¿‘è¯·æ±‚: ${formatDate(o.last_request_time)}
                            </div>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 10px;">
                            <button class="btn btn-sm" style="background: var(--primary);" onclick="prepareEditOutput(${o.id})">ä¿®æ”¹</button>
                            <button class="btn btn-sm" style="background: ${o.is_enabled === false ? '#10b981' : '#64748b'};" onclick="toggleOutputStatus(${o.id}, ${o.is_enabled !== false})">
                                ${o.is_enabled === false ? 'å¯ç”¨' : 'ç¦ç”¨'}
                            </button>
                            <button class="btn btn-sm" style="background: #10b981;" onclick="refreshOutput(${o.id})">åˆ·æ–°æº</button>
                            <button class="btn btn-sm" style="background: #3b82f6;" onclick="viewOutputPreview('${o.slug}', '${o.name}')">é¢„è§ˆ</button>
                            <button class="btn btn-sm" style="background: #ef4444;" onclick="deleteOutput(${o.id})">åˆ é™¤</button>
                        </div>
                    </div>
                `}).join('');
            } catch (err) {
                console.error('è·å–èšåˆåˆ—è¡¨å¤±è´¥:', err);
            }
        }

        async function toggleOutputStatus(id, currentStatus) {
            const out = allOutputs.find(o => o.id === id);
            if (!out) return;

            const updated = {
                ...out,
                is_enabled: !currentStatus
            };

            try {
                const res = await fetch(`/outputs/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updated)
                });
                if (res.ok) {
                    showStatus(updated.is_enabled ? 'å·²å¯ç”¨èšåˆ' : 'å·²ç¦ç”¨èšåˆ');
                    fetchOutputs();
                } else {
                    const errData = await res.json();
                    alert('æ“ä½œå¤±è´¥: ' + (errData.detail || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (err) {
                alert('ç½‘ç»œé”™è¯¯: ' + err.message);
            }
        }

        async function copyToClipboard(text) {
            try {
                // å…ˆè¯•æ–°çš„ API
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(text);
                    showStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    return;
                }
                throw new Error('Clipboard API unavailable');
            } catch (err) {
                // é™çº§æ–¹æ¡ˆ (HTTP è¿™ç§ä¸å®‰å…¨ç¯å¢ƒ)
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.style.position = "fixed";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ (Fallback)');
                } catch (fallbackErr) {
                    console.error('å¤åˆ¶å¤±è´¥:', fallbackErr);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶: ' + text);
                }
            }
        }

        function showStatus(msg) {
            const s = document.getElementById('status');
            s.innerText = msg;
            s.style.display = 'block';
            s.style.background = '#6366f1';
            setTimeout(() => s.style.display = 'none', 3000);
        }

        // --- å¤šé€‰åŠç»Ÿè®¡é€»è¾‘ ---

        function toggleChannelSelection(id, isChecked) {
            id = parseInt(id); // ç¡®ä¿ ID ä¸ºæ•´æ•°

            // æ›´æ–°é€‰ä¸­çŠ¶æ€é›†åˆ
            if (isChecked) {
                window.selectedChannelIds.add(id);
            } else {
                window.selectedChannelIds.delete(id);
            }

            // åŒæ­¥æ‰€æœ‰ç›¸åŒ ID çš„å¤é€‰æ¡†
            const duplicates = document.querySelectorAll(`.ch-checkbox[data-id="${id}"]`);
            duplicates.forEach(cb => {
                if (cb.checked !== isChecked) {
                    cb.checked = isChecked;
                }
            });

            updatePreviewStats();
        }

        function toggleSelectAll(checked) {
            if (checked) {
                // é€‰ä¸­å½“å‰è¿‡æ»¤åçš„æ‰€æœ‰é¢‘é“
                filteredChannels.forEach(c => window.selectedChannelIds.add(c.id));
            } else {
                // å–æ¶ˆå…¨é€‰
                window.selectedChannelIds.clear();
            }
            updateSelectionUI();
        }

        /**
         * åé€‰ï¼šé€‰ä¸­ç›®å‰æœªé€‰ä¸­çš„ï¼Œå–æ¶ˆé€‰ä¸­å·²é€‰ä¸­çš„ï¼ˆä»…é™å½“å‰è¿‡æ»¤ç»“æœï¼‰
         */

        function invertSelection() {
            const currentSet = new Set(window.selectedChannelIds);
            window.selectedChannelIds.clear();

            filteredChannels.forEach(c => {
                if (!currentSet.has(c.id)) {
                    window.selectedChannelIds.add(c.id);
                }
            });
            updateSelectionUI();
        }

        function updateSelectionUI() {
            // ç›´æ¥æ›´æ–° DOMï¼Œä¸é‡ç»˜å…¨è¡¨
            const checkboxes = document.querySelectorAll('.ch-checkbox');
            checkboxes.forEach(cb => {
                const id = parseInt(cb.dataset.id);
                if (!isNaN(id)) {
                    cb.checked = window.selectedChannelIds.has(id);
                }
            });
            updatePreviewStats();
        }

        function selectByStatus(enabled) {
            // æŠŠçŠ¶æ€å¯¹å¾—ä¸Šçš„éƒ½å‹¾ä¸Š
            filteredChannels.forEach(c => {
                const isEnabled = c.is_enabled !== false;
                if (isEnabled === enabled) {
                    window.selectedChannelIds.add(c.id);
                }
            });
            updateSelectionUI();
        }

        async function batchSetStatus(enable) {
            if (window.selectedChannelIds.size === 0) {
                alert("è¯·å…ˆå‹¾é€‰éœ€è¦æ“ä½œçš„é¢‘é“ï¼");
                return;
            }

            const actionName = enable ? "å¯ç”¨" : "ç¦ç”¨";
            const rowCount = filteredChannels.filter(c => window.selectedChannelIds.has(c.id)).length;
            if (!confirm(`ç¡®å®šè¦æ‰¹é‡ ${actionName} é€‰ä¸­çš„ ${rowCount} ä¸ªé¢‘é“å—ï¼Ÿ`)) return;

            const btnId = enable ? 'batch_enable_btn' : 'batch_disable_btn';
            const btn = document.getElementById(btnId);
            const originalText = btn.innerText;
            btn.disabled = true;

            // æ‰¾æ‰¾çœ‹æœ‰å“ªäº›çœŸçš„éœ€è¦æ”¹
            const targets = [];
            window.selectedChannelIds.forEach(id => {
                // åªèƒ½æ‰¾åˆ°å½“å‰æœå‡ºæ¥çš„ï¼Œå¦‚æœç”¨æˆ·æ”¹äº†æœç´¢è¯ï¼Œå¯èƒ½æ‰¾ä¸åˆ°å¯¹è±¡
                // ä½† ID è¿˜åœ¨ Set é‡Œï¼Œæ‰€ä»¥æ‰¹é‡æ“ä½œè¿˜æ˜¯æœ‰æ•ˆçš„
            });



            let changedCount = 0;
            const total = window.selectedChannelIds.size;
            let index = 0;

            for (const id of window.selectedChannelIds) {
                index++;
                btn.innerText = `å¤„ç†ä¸­ ${index}/${total}`;

                const c = currentChannels.find(ch => ch.id === id);
                if (c) {
                    const isEnabled = c.is_enabled !== false;
                    if (isEnabled !== enable) {
                        try {
                            // åˆ‡æ¢çŠ¶æ€
                            await fetch(`/channels/${id}/toggle`, { method: 'POST' });
                            c.is_enabled = enable; // å³æ—¶æ›´æ–°æœ¬åœ°æ•°æ®
                            changedCount++;
                        } catch (e) {
                            console.error(`Failed to toggle ${id}`, e);
                        }
                    }
                }
            }

            btn.innerText = originalText;
            btn.disabled = false;

            // Update UI
            updateSelectionUI(); // åˆ·ä¸‹ç»Ÿè®¡
            // åˆ·æ–°è¡¨ï¼Œçœ‹çœ‹æ”¹åŠ¨
            renderOffset = 0;
            document.getElementById('channel_list_container').scrollTop = 0;
            renderBaseTable(document.getElementById('channel_list'), window.lastRenderShowActions);

            showToast(`æ‰¹é‡æ“ä½œå®Œæˆï¼Œå…±ä¿®æ”¹ ${changedCount} ä¸ªé¢‘é“`, 'success');
        }

        function updatePreviewStats() {
            const total = filteredChannels.length;
            const enabledCount = filteredChannels.filter(c => c.is_enabled !== false).length;
            const selected = filteredChannels.filter(c => window.selectedChannelIds.has(c.id)).length;

            const statsEl = document.getElementById('preview_stats');
            if (statsEl) {
                let html = `å…± ${total} ä¸ªé¢‘é“ / å·²å¯ç”¨ ${enabledCount} ä¸ª`;
                if (window.lastRenderShowActions) {
                    html += ` <span style="margin-left:10px; opacity:0.6;">(å·²é€‰ ${selected} ä¸ª)</span>`;
                }
                statsEl.innerHTML = html;
            }

            // æ›´æ–°å¤§å¤é€‰æ¡†çŠ¶æ€
            const master = document.getElementById('master_checkbox');
            if (master) {
                const allSelected = filteredChannels.length > 0 && filteredChannels.every(c => window.selectedChannelIds.has(c.id));
                master.checked = allSelected;
                master.indeterminate = selected > 0 && !allSelected;
            }
        }

        fetchSubs();
        fetchOutputs();
    </script>
</body>

</html>